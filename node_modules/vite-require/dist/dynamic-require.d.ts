import { type ResolvedConfig } from 'vite';
import { type Analyzed } from './analyze';
import { type Options } from './index';
import { Resolve } from 'vite-plugin-dynamic-import';
/**
 * ```
 * At present, divide `require(id: Literal)` into three cases
 * 目前，将 `require(id: Literal)` 分为三种情况
 *
 * ①(🎯)
 * In the top-level scope and can be converted to `import` directly
 * 在顶层作用域，并且直接转换成 import
 *
 * ②(🚧)
 * If the `id` in `require(id: Literal)` is a literal string, the `require` statement will be promoted to the top-level scope and become an `import` statement
 * 如果 require(id: Literal) 中的 id 是字面量字符串，require 语句将会被提升到顶级作用域，变成 import 语句
 *
 * ③(🚧)
 * If the `id` in `require(dynamic-id)` is a dynamic-id, the `require` statement will be converted to `__matchRequireRuntime` function
 * 如果 require(dynamic-id) 中的 id 动态 id，require 语句将会被转换成 __matchRequireRuntime 函数
 * ```
 */
export declare class DynamicRequire {
    private options;
    private config;
    private resolve;
    private EXT;
    constructor(options: Options, config: ResolvedConfig, resolve?: Resolve);
    transform(analyzed: Analyzed, importer: string): Promise<string>;
    /**
     * If importee ends in a asset file, it might be better to just import the default module.
     */
    private generatedImportAs;
}
