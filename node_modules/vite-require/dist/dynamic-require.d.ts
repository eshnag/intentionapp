import { type ResolvedConfig } from 'vite';
import { type Analyzed } from './analyze';
import { type Options } from './index';
import { Resolve } from 'vite-plugin-dynamic-import';
/**
 * ```
 * At present, divide `require(id: Literal)` into three cases
 * ç›®å‰ï¼Œå°† `require(id: Literal)` åˆ†ä¸ºä¸‰ç§æƒ…å†µ
 *
 * â‘ (ğŸ¯)
 * In the top-level scope and can be converted to `import` directly
 * åœ¨é¡¶å±‚ä½œç”¨åŸŸï¼Œå¹¶ä¸”ç›´æ¥è½¬æ¢æˆ import
 *
 * â‘¡(ğŸš§)
 * If the `id` in `require(id: Literal)` is a literal string, the `require` statement will be promoted to the top-level scope and become an `import` statement
 * å¦‚æœ require(id: Literal) ä¸­çš„ id æ˜¯å­—é¢é‡å­—ç¬¦ä¸²ï¼Œrequire è¯­å¥å°†ä¼šè¢«æå‡åˆ°é¡¶çº§ä½œç”¨åŸŸï¼Œå˜æˆ import è¯­å¥
 *
 * â‘¢(ğŸš§)
 * If the `id` in `require(dynamic-id)` is a dynamic-id, the `require` statement will be converted to `__matchRequireRuntime` function
 * å¦‚æœ require(dynamic-id) ä¸­çš„ id åŠ¨æ€ idï¼Œrequire è¯­å¥å°†ä¼šè¢«è½¬æ¢æˆ __matchRequireRuntime å‡½æ•°
 * ```
 */
export declare class DynamicRequire {
    private options;
    private config;
    private resolve;
    private EXT;
    constructor(options: Options, config: ResolvedConfig, resolve?: Resolve);
    transform(analyzed: Analyzed, importer: string): Promise<string>;
    /**
     * If importee ends in a asset file, it might be better to just import the default module.
     */
    private generatedImportAs;
}
