"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseId = exports.MagicString = exports.simpleWalk = exports.isCommonjs = exports.cleanUrl = exports.builtins = exports.KNOWN_CSS_TYPES = exports.KNOWN_ASSET_TYPES = exports.KNOWN_SFC_EXTENSIONS = exports.JS_EXTENSIONS = exports.extractIdRE = exports.normallyIdRE = exports.hashRE = exports.queryRE = exports.singlelineCommentsRE = exports.multilineCommentsRE = void 0;
const module_1 = require("module");
// ------------------------------------------------- RegExp
exports.multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//g;
exports.singlelineCommentsRE = /\/\/.*/g;
exports.queryRE = /\?.*$/s;
exports.hashRE = /#.*$/s;
// this is probably less accurate
exports.normallyIdRE = /^\.{1,2}\/[.-/\w]+(\.\w+)$/;
// [, startQuotation, id]
exports.extractIdRE = /^([`'"]{1})(.*)$/;
// ------------------------------------------------- const
exports.JS_EXTENSIONS = [
    '.mjs',
    '.js',
    '.ts',
    '.jsx',
    '.tsx',
    '.cjs'
];
exports.KNOWN_SFC_EXTENSIONS = [
    '.vue',
    '.svelte',
];
// https://github.com/vitejs/vite/blob/d6418605577319b2f92ea37081e34376bb47b286/packages/vite/src/node/constants.ts#L66
exports.KNOWN_ASSET_TYPES = [
    // images
    'png',
    'jpg',
    'jpeg',
    'gif',
    'svg',
    'ico',
    'webp',
    'avif',
    // media
    'mp4',
    'webm',
    'ogg',
    'mp3',
    'wav',
    'flac',
    'aac',
    // fonts
    'woff2?',
    'eot',
    'ttf',
    'otf',
    // other
    'webmanifest',
    'pdf',
    'txt'
];
exports.KNOWN_CSS_TYPES = [
    'css',
    'less',
    'sass',
    'scss',
    'styl',
    'stylus',
    'pcss',
    'postcss',
];
exports.builtins = [
    ...module_1.builtinModules.filter(m => !m.startsWith('_')),
    ...module_1.builtinModules.filter(m => !m.startsWith('_')).map(m => `node:${m}`)
];
// ------------------------------------------------- function
function cleanUrl(url) {
    return url.replace(exports.hashRE, '').replace(exports.queryRE, '');
}
exports.cleanUrl = cleanUrl;
function isCommonjs(code) {
    // Avoid matching the content of the comment
    code = code
        .replace(exports.multilineCommentsRE, '')
        .replace(exports.singlelineCommentsRE, '');
    return /\b(?:require|module|exports)\b/.test(code);
}
exports.isCommonjs = isCommonjs;
function simpleWalk(ast, visitors, ancestors = []) {
    var _a;
    if (!ast)
        return;
    if (Array.isArray(ast)) {
        for (const element of ast) {
            simpleWalk(element, visitors, ancestors);
        }
    }
    else {
        ancestors = ancestors.concat(ast);
        for (const key of Object.keys(ast)) {
            (typeof ast[key] === 'object' &&
                simpleWalk(ast[key], visitors, ancestors));
        }
    }
    (_a = visitors[ast.type]) === null || _a === void 0 ? void 0 : _a.call(visitors, ast, ancestors);
}
exports.simpleWalk = simpleWalk;
// TODO
simpleWalk.async = function simpleWalkAsync() { };
class MagicString {
    constructor(str) {
        this.str = str;
        this.starts = '';
        this.ends = '';
    }
    append(content) {
        this.ends += content;
        return this;
    }
    prepend(content) {
        this.starts = content + this.starts;
        return this;
    }
    overwrite(start, end, content) {
        if (end < start) {
            throw new Error(`"end" con't be less than "start".`);
        }
        if (!this.overwrites) {
            this.overwrites = [];
        }
        this.overwrites.push({ loc: [start, end], content });
        return this;
    }
    toString() {
        let str = this.str;
        if (this.overwrites) {
            const arr = [...this.overwrites].sort((a, b) => b.loc[0] - a.loc[0]);
            for (const { loc: [start, end], content } of arr) {
                // TODO: check start or end overlap
                str = str.slice(0, start) + content + str.slice(end);
            }
        }
        return this.starts + str + this.ends;
    }
}
exports.MagicString = MagicString;
function parseId(id) {
    let [startQuotation, _id] = ['', id];
    const matched = id.match(exports.extractIdRE);
    if (matched) {
        [, startQuotation, _id] = matched;
    }
    return [startQuotation, _id];
}
exports.parseId = parseId;
